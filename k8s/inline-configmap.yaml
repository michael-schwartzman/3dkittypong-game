apiVersion: v1
kind: ConfigMap
metadata:
  name: kittypong-inline-html
  namespace: default
data:
  index.html: |
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
        <title>3D Kitty Pong Game - Working Version</title>
        <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
        <style>
            @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
            * { margin: 0; padding: 0; box-sizing: border-box; }
            html, body { height: 100%; width: 100%; overflow: hidden; background: #120021; font-family: 'Press Start 2P', cursive; color: white; }
            body { background: linear-gradient(135deg, #120021, #300639, #120021); background-size: 400% 400%; animation: gradient 15s ease infinite; display: flex; justify-content: center; align-items: center; overscroll-behavior: none; touch-action: manipulation; }
            @keyframes gradient { 0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; } }
            .game-container { width: 98vw; max-width: 1600px; height: 98vh; max-height: 1000px; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 60px 20px 20px; border-radius: 15px; box-shadow: 0 0 40px #ff00cc, 0 0 80px rgba(0, 255, 255, 0.5), 0 0 120px #ff0066; background-color: rgba(0, 0, 0, 0.7); position: relative; overflow: hidden; user-select: none; }
            .kitty-header { display: flex; align-items: center; justify-content: center; margin-bottom: 15px; width: 100%; z-index: 20; }
            .kitty-header h1 { font-size: 42px; text-align: center; margin: 0 15px; text-transform: uppercase; letter-spacing: 3px; background: linear-gradient(to right, #ff00ff, #00ffff, #ffff00, #ff00aa, #00ffcc); -webkit-background-clip: text; background-clip: text; color: transparent; animation: rainbow-text 3s linear infinite; text-shadow: 0 0 8px rgba(255, 255, 255, 0.5); font-weight: bold; }
            .kitty-emoji { font-size: 42px; animation: bounce 1s infinite alternate; }
            @keyframes bounce { 0% { transform: translateY(0); } 100% { transform: translateY(-10px); } }
            @keyframes rainbow-text { 0% { filter: hue-rotate(0deg); } 100% { filter: hue-rotate(360deg); } }
            #game-canvas-container { width: 100%; height: 70%; position: relative; overflow: hidden; border-radius: 8px; box-shadow: 0 0 20px rgba(255, 0, 255, 0.5), 0 0 40px rgba(0, 255, 255, 0.3); background-color: rgba(0, 0, 0, 0.5); margin: 10px auto 15px; z-index: 10; }
            #pong { width: 100%; height: 100%; display: block; border-radius: 15px; border: 2px solid #ff00ff; box-shadow: 0 0 20px #ff66c4; animation: rainbow-box-shadow 5s infinite; }
            @keyframes rainbow-box-shadow { 0% { box-shadow: 0 0 15px red; } 14% { box-shadow: 0 0 15px #ff8000; } 28% { box-shadow: 0 0 15px yellow; } 42% { box-shadow: 0 0 15px lime; } 56% { box-shadow: 0 0 15px cyan; } 70% { box-shadow: 0 0 15px #0080ff; } 84% { box-shadow: 0 0 15px #8000ff; } 100% { box-shadow: 0 0 15px red; } }
            #score-display { width: 100%; display: flex; justify-content: center; margin-top: 10px; font-weight: bold; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7); letter-spacing: 2px; padding: 5px 15px; border-radius: 15px; background: rgba(255, 255, 255, 0.3); box-shadow: 0 0 10px rgba(255, 105, 180, 0.7); z-index: 20; }
            #game-score { font-size: 32px; display: flex; width: 100%; justify-content: space-between; margin-bottom: 10px; text-shadow: 0 0 10px #ff00ff; }
            #player-score, #computer-score { min-width: 60px; text-align: center; padding: 5px 10px; border-radius: 8px; font-weight: bold; transition: transform 0.3s, color 0.3s; }
            #player-score { background-color: rgba(102, 204, 255, 0.3); border: 2px solid #66ccff; color: #66ccff; }
            #computer-score { background-color: rgba(255, 102, 196, 0.3); border: 2px solid #ffb8de; color: #ffb8de; }
            .controls { width: 100%; display: flex; flex-direction: column; align-items: center; margin: 0.5rem auto; text-align: center; z-index: 20; }
            .control-buttons { display: flex; gap: 20px; margin-bottom: 10px; justify-content: center; }
            button { font-family: 'Press Start 2P', cursive; background: linear-gradient(to right, #ff00aa, #aa00ff); border: none; padding: 12px 25px; border-radius: 25px; font-size: 18px; font-weight: bold; color: white; cursor: pointer; transition: all 0.3s; border: 2px solid #ff00ff; box-shadow: 0 0 10px #00ffcc; }
            button:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 0, 255, 0.7); }
            button:active { transform: scale(0.95); }
            .instructions { font-size: 16px; text-align: center; margin: 10px 0; color: #f0f0f0; text-shadow: 0 0 5px #ff00ff; opacity: 0.8; }
            .corner-kitty { position: absolute; font-size: 30px; z-index: 10; animation-duration: 3s; animation-iteration-count: infinite; animation-timing-function: ease-in-out; filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.5)); }
            .corner-kitty-top-left { top: 15px; left: 15px; animation-name: kitty-tl; }
            .corner-kitty-top-right { top: 15px; right: 15px; animation-name: kitty-tr; }
            .corner-kitty-bottom-left { bottom: 15px; left: 15px; animation-name: kitty-bl; }
            .corner-kitty-bottom-right { bottom: 15px; right: 15px; animation-name: kitty-br; }
            @keyframes kitty-tl { 0%, 100% { transform: translate(0) rotate(-5deg); } 50% { transform: translate(5px, 5px) rotate(5deg); } }
            @keyframes kitty-tr { 0%, 100% { transform: translate(0) rotate(5deg); } 50% { transform: translate(-5px, 5px) rotate(-5deg); } }
            @keyframes kitty-bl { 0%, 100% { transform: translate(0) rotate(-10deg); } 50% { transform: translate(5px, -5px) rotate(10deg); } }
            @keyframes kitty-br { 0%, 100% { transform: translate(0) rotate(10deg); } 50% { transform: translate(-5px, -5px) rotate(-10deg); } }
            .side-kitty { position: absolute; font-size: 28px; z-index: 5; filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.7)); }
            .side-kitty-left { left: 20px; top: 50%; transform: translateY(-50%); animation: float-left 4s ease-in-out infinite; }
            .side-kitty-right { right: 20px; top: 50%; transform: translateY(-50%); animation: float-right 4.5s ease-in-out infinite; }
            .side-kitty-top { top: 80px; left: 50%; transform: translate(-50%); animation: float-top 3.5s ease-in-out infinite; }
            .side-kitty-bottom { bottom: 20px; left: 50%; transform: translate(-50%); animation: float-bottom 5s ease-in-out infinite; }
            @keyframes float-left { 0%, 100% { transform: translateY(-50%) translate(0) rotate(-5deg); } 50% { transform: translateY(-50%) translate(10px) rotate(5deg); } }
            @keyframes float-right { 0%, 100% { transform: translateY(-50%) translate(0) rotate(5deg); } 50% { transform: translateY(-50%) translate(-10px) rotate(-5deg); } }
            @keyframes float-top { 0%, 100% { transform: translate(-50%) translateY(0) rotate(-3deg); } 50% { transform: translate(-50%) translateY(10px) rotate(3deg); } }
            @keyframes float-bottom { 0%, 100% { transform: translate(-50%) translateY(0) rotate(3deg); } 50% { transform: translate(-50%) translateY(-10px) rotate(-3deg); } }
            #game-info-container { width: 100%; font-size: 18px; margin-top: 10px; z-index: 20; display: flex; justify-content: space-between; }
            #game-timer, #game-difficulty { padding: 5px 10px; border-radius: 5px; background-color: rgba(0, 0, 0, 0.3); animation: glow 2s alternate infinite; }
            @keyframes glow { 0% { box-shadow: 0 0 5px #00ffcc; } 100% { box-shadow: 0 0 15px #ff66c4; } }
            .touch-controls { display: none; width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 5; }
            .touch-zone { background-color: transparent; position: absolute; width: 100%; height: 50%; }
            .touch-up { top: 0; } .touch-down { bottom: 0; }
            @media (max-width: 768px) { .kitty-header h1 { font-size: 28px; } .touch-controls { display: block; } #game-canvas-container { height: 60vh; } .kitty-emoji { font-size: 28px; } .controls button { font-size: 16px; padding: 10px 20px; } .mouse-instructions { display: none; } .mobile-instructions { display: inline; } }
            @media (min-width: 769px) { .mobile-instructions { display: none; } .mouse-instructions { display: inline; } }
            .sound-on { background: linear-gradient(45deg, #00ccff, #0066ff); }
            .sound-off { background: linear-gradient(45deg, #ff6699, #cc0066); }
        </style>
    </head>
    <body>
        <div class="game-container">
            <div class="corner-kitty corner-kitty-top-left">üò∏</div>
            <div class="corner-kitty corner-kitty-top-right">üòª</div>
            <div class="corner-kitty corner-kitty-bottom-left">üòΩ</div>
            <div class="corner-kitty corner-kitty-bottom-right">üôÄ</div>
            <div class="side-kitty side-kitty-left">üòπ</div>
            <div class="side-kitty side-kitty-right">üò∫</div>
            <div class="side-kitty side-kitty-top">üòª</div>
            <div class="side-kitty side-kitty-bottom">üòΩ</div>
            
            <div class="kitty-header">
                <span class="kitty-emoji">üê±</span>
                <h1>3D KITTY PONG</h1>
                <span class="kitty-emoji">üê±</span>
            </div>
            
            <div id="score-display">
                <div id="game-score">
                    <div id="player-score">0</div>
                    <div id="computer-score">0</div>
                </div>
            </div>
            
            <div id="game-canvas-container">
                <canvas id="pong"></canvas>
            </div>

            <div class="controls">
                <div class="control-buttons">
                    <button id="start-btn">Start Game</button>
                    <button id="sound-btn" class="sound-on">Sound: ON</button>
                </div>
                <p class="instructions">Use W/S or Up/Down arrows to move your paddle<span class="mouse-instructions">, or move your mouse over the game</span><span class="mobile-instructions">, or touch the screen to control</span></p>
            </div>
            
            <div id="game-info-container">
                <div id="game-timer">Time: <span id="timer-value">0</span>s</div>
                <div id="game-difficulty">Diffulkitty: <span id="speed-value">1</span>x</div>
            </div>
            
            <div class="touch-controls">
                <div class="touch-zone touch-up"></div>
                <div class="touch-zone touch-down"></div>
            </div>
        </div>

        <script>
            console.log('üê± 3D Kitty Pong loading...');
            
            function initGame() {
                console.log('üê± Initializing game...');
                
                if (typeof THREE === 'undefined') {
                    console.error('Three.js not loaded! Retrying...');
                    setTimeout(initGame, 1000);
                    return;
                }
                
                startGame();
            }
            
            function startGame() {
                console.log('üê± Starting 3D Kitty Pong game...');
                
                const canvas = document.getElementById('pong');
                if (!canvas) { console.error('Canvas not found!'); return; }
                
                const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
                
                const updateSize = () => {
                    const container = canvas.parentElement;
                    const width = container.clientWidth;
                    const height = container.clientHeight;
                    renderer.setSize(width, height);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                };
                
                updateSize();
                renderer.setClearColor(0x000000, 0.1);

                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                camera.position.z = 15;

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(5, 5, 5);
                scene.add(directionalLight);

                const borderGeometry = new THREE.BoxGeometry(30, 20, 1);
                const borderEdges = new THREE.EdgesGeometry(borderGeometry);
                const borderMaterial = new THREE.LineBasicMaterial({ color: 0x9d00fd, linewidth: 2 });
                const border = new THREE.LineSegments(borderEdges, borderMaterial);
                border.position.z = -0.5;
                scene.add(border);

                const borderColors = [0xff00ff, 0x00ffff, 0xffff00, 0xff6600];
                const borderLights = [];
                const borderPositions = [new THREE.Vector3(-14.5, 9.5, 0), new THREE.Vector3(14.5, 9.5, 0), new THREE.Vector3(14.5, -9.5, 0), new THREE.Vector3(-14.5, -9.5, 0)];

                for (let i = 0; i < 4; i++) {
                    const light = new THREE.PointLight(borderColors[i], 1, 8, 2);
                    light.position.copy(borderPositions[i]);
                    scene.add(light);
                    borderLights.push(light);
                }

                function updateBorderEffects() {
                    const time = Date.now() * 0.0002 % 1;
                    borderMaterial.color.setHSL(time, 1, 0.6);
                    const intensity = Math.sin(Date.now() * 0.002) * 0.5 + 1;
                    for (let i = 0; i < borderLights.length; i++) {
                        borderLights[i].intensity = intensity;
                        const lightHue = (time + i * 0.25) % 1;
                        borderLights[i].color.setHSL(lightHue, 1, 0.5);
                    }
                }

                const createPaddleMaterial = (color) => new THREE.MeshPhongMaterial({ color: color, shininess: 100, emissive: color, emissiveIntensity: 0.7 });
                const paddleGeometry = new THREE.BoxGeometry(0.5, 4, 1);
                const leftPaddle = new THREE.Mesh(paddleGeometry, createPaddleMaterial(0x00ccff));
                const rightPaddle = new THREE.Mesh(paddleGeometry, createPaddleMaterial(0xff6600));
                leftPaddle.position.x = -14;
                rightPaddle.position.x = 14;
                scene.add(leftPaddle);
                scene.add(rightPaddle);

                const leftPaddleLight = new THREE.PointLight(0x00ccff, 1.5, 6, 2);
                leftPaddleLight.position.set(-14, 0, 0);
                scene.add(leftPaddleLight);
                const rightPaddleLight = new THREE.PointLight(0xff6600, 1.5, 6, 2);
                rightPaddleLight.position.set(14, 0, 0);
                scene.add(rightPaddleLight);

                function updatePaddleLights() {
                    leftPaddleLight.position.y = leftPaddle.position.y;
                    const leftTime = Date.now() * 0.0005 % 1;
                    const leftColor = new THREE.Color().setHSL(leftTime, 1, 0.5);
                    leftPaddleLight.color = leftColor;
                    leftPaddle.material.emissive = leftColor;
                    rightPaddleLight.position.y = rightPaddle.position.y;
                    const rightTime = (Date.now() * 0.0005 + 0.5) % 1;
                    const rightColor = new THREE.Color().setHSL(rightTime, 1, 0.5);
                    rightPaddleLight.color = rightColor;
                    rightPaddle.material.emissive = rightColor;
                    const intensity = Math.sin(Date.now() * 0.003) * 0.5 + 1.5;
                    leftPaddleLight.intensity = intensity;
                    rightPaddleLight.intensity = intensity;
                }

                function createKittyMaterial(color, emoji) {
                    const canvas = document.createElement('canvas');
                    canvas.width = 256; canvas.height = 256;
                    const context = canvas.getContext('2d');
                    context.fillStyle = color;
                    context.beginPath();
                    context.arc(128, 128, 128, 0, Math.PI * 2);
                    context.fill();
                    context.font = '160px Arial';
                    context.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(emoji, 128, 118);
                    const texture = new THREE.CanvasTexture(canvas);
                    return new THREE.MeshPhongMaterial({ map: texture, shininess: 50 });
                }

                const ballMaterials = [
                    createKittyMaterial('#ffc0cb', 'üò∫'),
                    createKittyMaterial('#ffb8de', 'üòª'),
                    createKittyMaterial('#ffa0d0', 'üò∏'),
                    createKittyMaterial('#ff90c8', 'üòΩ'),
                    createKittyMaterial('#ff80c0', 'üôÄ')
                ];

                const ballGeometry = new THREE.SphereGeometry(1, 32, 32);
                const ball = new THREE.Mesh(ballGeometry, ballMaterials[0]);
                ball.userData = { currentFace: 0, lastFaceChange: 0, velocity: new THREE.Vector3(0.2, 0.1, 0) };
                scene.add(ball);

                function updateBallExpression(time) {
                    if (time - ball.userData.lastFaceChange > 2000 + Math.random() * 1000) {
                        ball.userData.currentFace = (ball.userData.currentFace + 1) % ballMaterials.length;
                        ball.material = ballMaterials[ball.userData.currentFace];
                        ball.userData.lastFaceChange = time;
                    }
                }

                const gameState = { gameRunning: false, playerScore: 0, computerScore: 0, ballSpeed: 0.2, difficultyMultiplier: 1 };
                const startBtn = document.getElementById('start-btn');
                const playerScoreEl = document.getElementById('player-score');
                const computerScoreEl = document.getElementById('computer-score');
                const timerEl = document.getElementById('timer-value');
                const speedEl = document.getElementById('speed-value');
                const soundBtn = document.getElementById('sound-btn');

                let soundEnabled = true;

                if (soundBtn) {
                    soundBtn.addEventListener('click', () => {
                        soundEnabled = !soundEnabled;
                        soundBtn.className = soundEnabled ? 'sound-on' : 'sound-off';
                        soundBtn.textContent = soundEnabled ? 'Sound: ON' : 'Sound: OFF';
                    });
                }

                const keys = { w: false, s: false, ArrowUp: false, ArrowDown: false };
                let keyboardActive = false, mouseY = 0, mouseActive = false;

                document.addEventListener('keydown', (e) => {
                    if (e.key in keys) { keys[e.key] = true; keyboardActive = true; mouseActive = false; }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.key in keys) { keys[e.key] = false; keyboardActive = Object.values(keys).some(k => k); }
                });
                window.addEventListener('mousemove', (e) => {
                    if (!gameState.gameRunning) return;
                    if (keyboardActive && (e.movementX !== 0 || e.movementY !== 0)) keyboardActive = false;
                    const normalizedY = (e.clientY / window.innerHeight) * 20 - 10;
                    mouseY = Math.max(-8, Math.min(8, normalizedY));
                    mouseActive = true;
                });

                let touchY = null;
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (!gameState.gameRunning) return;
                    const rect = canvas.getBoundingClientRect();
                    touchY = ((e.touches[0].clientY - rect.top) / rect.height) * 20 - 10;
                }, { passive: false });
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!gameState.gameRunning) return;
                    const rect = canvas.getBoundingClientRect();
                    touchY = ((e.touches[0].clientY - rect.top) / rect.height) * 20 - 10;
                }, { passive: false });
                canvas.addEventListener('touchend', () => { touchY = null; });

                function playSound(type) {
                    if (!soundEnabled) return;
                    try {
                        const ctx = new (window.AudioContext || window.webkitAudioContext)();
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain); gain.connect(ctx.destination);
                        if (type === 'paddle') { osc.type = 'sine'; osc.frequency.setValueAtTime(880, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(440, ctx.currentTime + 0.1); gain.gain.setValueAtTime(0.1, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1); osc.start(); osc.stop(ctx.currentTime + 0.1); }
                        else if (type === 'wall') { osc.type = 'triangle'; osc.frequency.setValueAtTime(220, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(110, ctx.currentTime + 0.05); gain.gain.setValueAtTime(0.08, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.05); osc.start(); osc.stop(ctx.currentTime + 0.05); }
                        else if (type === 'score') { osc.type = 'sine'; osc.frequency.setValueAtTime(800, ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.2); gain.gain.setValueAtTime(0.1, ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2); osc.start(); osc.stop(ctx.currentTime + 0.2); }
                    } catch (e) { console.log("Sound couldn't play"); }
                }

                function resetGame() {
                    gameState.playerScore = 0; gameState.computerScore = 0; gameState.difficultyMultiplier = 1;
                    if (playerScoreEl) playerScoreEl.textContent = '0';
                    if (computerScoreEl) computerScoreEl.textContent = '0';
                    resetBall();
                }

                function resetBall() {
                    ball.position.set(0, 0, 0);
                    ball.userData.velocity.set(Math.random() > 0.5 ? gameState.ballSpeed : -gameState.ballSpeed, (Math.random() - 0.5) * gameState.ballSpeed, 0);
                }

                if (startBtn) {
                    startBtn.addEventListener('click', () => {
                        if (gameState.gameRunning) resetGame();
                        else { resetGame(); gameState.gameRunning = true; startBtn.textContent = 'Restart Game'; gameLoop(); }
                    });
                }

                function updatePlayer() {
                    const speed = 0.3 * gameState.difficultyMultiplier;
                    if (keyboardActive) {
                        if ((keys.w || keys.ArrowUp) && leftPaddle.position.y < 8) leftPaddle.position.y += speed;
                        if ((keys.s || keys.ArrowDown) && leftPaddle.position.y > -8) leftPaddle.position.y -= speed;
                    } else if (mouseActive) {
                        const targetY = -mouseY; const currentY = leftPaddle.position.y;
                        leftPaddle.position.y += (targetY - currentY) * 0.15 * gameState.difficultyMultiplier;
                    } else if (touchY !== null) {
                        const currentY = leftPaddle.position.y;
                        leftPaddle.position.y += (touchY - currentY) * 0.15 * gameState.difficultyMultiplier;
                    }
                    leftPaddle.position.y = Math.max(-8, Math.min(8, leftPaddle.position.y));

                    if (gameState.gameRunning) {
                        const ballY = ball.position.y; const aiSpeed = 0.15 * gameState.difficultyMultiplier;
                        if (rightPaddle.position.y < ballY && rightPaddle.position.y < 8) rightPaddle.position.y += aiSpeed;
                        if (rightPaddle.position.y > ballY && rightPaddle.position.y > -8) rightPaddle.position.y -= aiSpeed;
                    }
                }

                function updateBall() {
                    if (!gameState.gameRunning) return;
                    ball.position.add(ball.userData.velocity);
                    ball.rotation.x += 0.02; ball.rotation.y += 0.03;

                    if (ball.position.y > 9 || ball.position.y < -9) {
                        ball.userData.velocity.y = -ball.userData.velocity.y;
                        playSound('wall');
                        ball.userData.currentFace = (ball.userData.currentFace + 1) % ballMaterials.length;
                        ball.material = ballMaterials[ball.userData.currentFace];
                        ball.userData.lastFaceChange = Date.now();
                    }

                    if ((ball.position.x < -13 && ball.position.x > -15 && ball.position.y < leftPaddle.position.y + 2 && ball.position.y > leftPaddle.position.y - 2) ||
                        (ball.position.x > 13 && ball.position.x < 15 && ball.position.y < rightPaddle.position.y + 2 && ball.position.y > rightPaddle.position.y - 2)) {
                        ball.userData.velocity.x = -ball.userData.velocity.x * 1.1;
                        playSound('paddle');
                        ball.userData.currentFace = (ball.userData.currentFace + 1) % ballMaterials.length;
                        ball.material = ballMaterials[ball.userData.currentFace];
                        ball.userData.lastFaceChange = Date.now();
                    }

                    if (ball.position.x < -15) {
                        gameState.computerScore++;
                        if (computerScoreEl) computerScoreEl.textContent = gameState.computerScore;
                        playSound('score'); resetBall();
                    }
                    if (ball.position.x > 15) {
                        gameState.playerScore++;
                        if (playerScoreEl) playerScoreEl.textContent = gameState.playerScore;
                        playSound('score'); resetBall();
                    }
                }

                let startTime = 0;
                function gameLoop(time) {
                    if (!startTime) startTime = time;
                    if (gameState.gameRunning) {
                        updatePlayer(); updateBall(); updatePaddleLights(); updateBallExpression(time); updateBorderEffects();
                        gameState.difficultyMultiplier += 0.0001;
                        if (speedEl) speedEl.textContent = gameState.difficultyMultiplier.toFixed(1) + 'x';
                        if (timerEl) timerEl.textContent = Math.floor(time / 1000);
                    }
                    renderer.render(scene, camera);
                    requestAnimationFrame(gameLoop);
                }

                window.addEventListener('resize', updateSize);
                resetBall(); renderer.render(scene, camera);
                console.log('üê± 3D Kitty Pong ready!');
            }

            if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initGame);
            else initGame();
        </script>
    </body>
    </html>